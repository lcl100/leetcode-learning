## 解法1
```java
class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        int diffCount = 0;// 计数器，记录相同索引位置字符不同的情况次数，如果超过两次则直接返回false
        char[] cs = new char[4];// 记录两对不同的字符，但cs[0]必须和cs[3]相同，cs[1]和cs[2]相同，如果不相同也返回false
        int c = 0;// 指针，指向cs数组的下标
        for (int i = 0; i < s1.length(); i++) {
            char c1 = s1.charAt(i);// s1字符串对应i索引的字符
            char c2 = s2.charAt(i);// s2字符串对应i索引的字符
            if (c1 != c2) {// 如果相同索引位置的两个字符不相等
                diffCount++;// 那么计数器加1
                if (diffCount > 2) {// 如果超过2次，则直接返回false
                    return false;
                }
                cs[c++] = c1;// 记录两个字符串中不相同的字符
                cs[c++] = c2;
            }
        }
        // diffCount==0表示两个字符串所有字符都相等，则直接返回true，也可以在最开始判断两个字符串是否相等然后返回，提高性能
        // diffCount == 2表示仅有两次相同索引位置的字符不同的情况
        // cs[0]==cs[3]&&cs[1]==cs[2]表示在diffCount等于2的情况，并且交换后的两个字符串要相等
        return diffCount == 0 || (diffCount == 2 && cs[0] == cs[3] && cs[1] == cs[2]);
    }
}
/*
    题目解析：
        1.关键字：字符串s1和字符串s2长度相等；只能交换一次；交换后两个字符串必须相等
        2.只能交换一次，也就是比较两个字符串相同索引位置的字符的不同次数只能有2次（因为交换肯定需要交换两个字符），如果超过2次，必定返回false
        3.交换后的两个字符串必须要相同，也就是说交换的四个字符必须两两相同
            例如：s1="caa"，s2="aaz"。
                - 相同索引位置的字符不同的情况只有两次，即'c'->'a'和'a'->'z'，但它们交换后两个字符串并不相等
        4.注意，如果两个字符串相等，那么直接可以返回true
    解题思路：

 */
/*
    执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
    内存消耗：36.4 MB, 在所有 Java 提交中击败了92.88% 的用户
 */
```