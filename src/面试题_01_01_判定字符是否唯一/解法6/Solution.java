package 面试题_01_01_判定字符是否唯一.解法6;

public class Solution {
    public boolean isUnique(String astr) {
        long bits = 0;// 转换为二进制全是0，long类型变量有64位二进制，足够存放26个小写字母的存在
        for (int i = 0; i < astr.length(); i++) {
            int c = astr.charAt(i) - 'a';// 获取当前小写字母的索引，'a'~'z' === 0~25
            // 假如bits现在为：0101 1101 表示已经存在5个字符了，分别是'a'、'c'、'd'、'e'和'g'字符
            // 而现在找到的c=2也就是说是'c'字符，(1<<c)= 0000 0100
            // bits & (1L << c) = 0101 1101 & 0000 0100 =0000 0100 = 4，不等于0，表示该处已经存在字符了
            if ((bits & (1L << c)) != 0) {
                // 有重复的，直接返回false
                return false;
            } else {
                // 标记当前位置有这个字符
                // 1<<c 表示将1的二进制数向左移c位，低位补0
                // 如：c=0，也就是说astr.charAt(i)='a'字符
                // 0000 0001 << 0 = 0000 0001   表示第0位已经有'a'字符了
                // bits |= (1 << 0) = 0000 0000 | 0000 0001 = 0000 0001
                // 如：c=1，也就是说astr.charAt(i)='b'字符
                // 0000 0001 << 1 = 0000 0010   表示第1位已经有'b'字符了
                // bits | = (1 << 1) = 0000 0001 | 0000 0010 = 0000 0011
                // 如：c=2，也就是说astr.charAt(i)='c'字符
                // 0000 0001 << 2 = 0000 0100   表示第2位已经有'c'字符了
                // bits |= (1 << 2) = 0000 0011 | 0000 0100 = 0000 0111
                bits |= (1L << c);
            }
        }
        return true;
    }
}
/*
    解题思路：
        0.位运算
    特别注意：
        1.本题并没有明确说明所有字符是小写字母，所以只是提供一种解题思路
 */
/*
    执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户
    内存消耗：36.4 MB, 在所有 Java 提交中击败了10.46% 的用户
 */